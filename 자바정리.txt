01. 자바란 무엇인가?
01 자바 소개
1) 자바의 탄생
2) 자바의 특징
3) 자바 플랫폼
4) JVM (자바 가상 머신)

02 JDK의 주요 기능
1) 제네릭 타입
2) 메타 데이터
3) 개선된 루프
4) 오토박싱/언박싱
5) static import
6) Formatter과 Scanner
7) Varags (Variable Arguments)
8) Simpler RMI interface generation 기법
9) 람다식
10) 단순해진 함수형 인터페이스의 사용
11) 영속 세대 (PERmanent Generation) 제거

03 JDK 설치와 환경 설정
1) 자바의 실행 구조

04 자바 API
1) 자바 API 란?
2) 자바 API의 구성
 
02. 자바 기본 문법
01 식별자와 예약어
1) 식별자
2) 예약어

02 자료형
1) 기본 자료형
2) 참조 자료형
3) 형 변환

03 연산자
1) 산술 연산자
2) 대입 연산자
3) 비교 연산자 (관계 연산자)
4) 논리 연산자
5) 비트 연산자
6) 시프트 연산자
7) 증감 연산 
8) 조건 연산자 (삼항 연산자)

03. 주석문과 제어문
01 주석문
1) 주석문이란?
2) 주석문을 사용하는 이유
3) 주석문의 종류

02 제어문
1) 분기문(비교문)
    - if 문 (단순 if / 단일 if~else / 다중 if)
    - switch문 
2) 반복문
    - for문 
    - 다중 for문
    - while문
    - do~while문
3) break문
    - break문
    - break label문
4) continue문
    - continue문
    - continue label문

04. 클래스와 배열
01 클래스와 객체의 개념
1) 클래스의 구조와 정의
2) 객체 생성과 멤버 접근법 
3) 캡슐화
4) 멤버 변수
5) 멤버 함수
6) 생성자
7) this와 this()
8) static 예약어


02 기본 클래스 익히기
1) String 클래스
2) StringBuffer 클래스
3) String Tokenizer 클래스
4) Wrapper 클래스
5) Formatter 클래스

03 배열
1) 1차원 배열
2) 배열을 이용한 개선된 루프
3) 오토박싱과 언박싱
4) 다차원 배열

04 Varargs (Variable Arguments)
1) 사용 방법
2) 사용 이유

05. 클래스 2
01 클래스 상속
1) 상속의 개념과 중요서
2) 상속되는 멤버의 제한과 은폐
3) 오버라이딩
4) super와 super()

02 final 예약어
1) 변수에서의 final
2) 메서드에서의 final
3) 클래스에서의 final

03 추상화
1) 추상화의 이해와 선언법
2) 추상 클래스의 상속 관계
3) 추상화의 활용

04 인터페이스
1) 인터페이스 정의와 선언, 구현법
2) 인터페이스 간의 상속
3) instanceof 예약어
4) Object 클래스

05 열거형
1) 열거형의 정의와 구성
2) 열거형의 실체
3) 열거형의 할용

06 내부클래스
1) 내부 클래스의 이해와 특징
2) 내부 클래스의 종류와 사용법



----------------------------------------------
06. 패키지와 예외
01 패키지
1) 상속의 개념과 중요성
2) 패키지 사용 방법
3) static imports문

02 예외
1) 예외처리에 대한 필요성과 이해
2) 예외의 종류
3) 예외 처리 방법
4) finally의 필요성
5) 예외 강제 발생
6) 사용자 정의 예외

03 단언
1) 단언의 문법

07. 제네릭과 컬렉션
01 제네릭
제네릭은 컬렉션(자료구조), 즉 쉽게 말해서 객체들을 저장(수집)하는 구조적인 성격을 보강하기 위해 제공되는 것이다.
1) 제네릭의 필요성
자바에서는 객체들을 담아 편하게 관리하기 위해 컬렉션(자료구조)를 제공한다.
컬렉션의 대부분이 어떤 객체를 담을 지 모르기 때문에 모든 자바 객체들의 base 객체(최상위 객체)인 Object로 저장되어 관리되도록 설계되어 있다.
이런 이유로 자바의 모든 객체는 컬렉션에 저장할 수 있게 되는데, 문제는 이런 컬렉션이 바로 하나의 컵에 물을 담을 수도 있고 물과 사이다를 섞어서 담을 수도 있으며, 거기다 식초도 담을 수 있는 컵과 같은 형태가 된다.
이런 것들을 확인할 수 있는 길은 눈으로 확인이 되지 않으며 직접 마셔보는, 즉 실행을 해보는 방법 밖에 없다.

그래서 제네릭을 통해 이제 프로그래머가 특정 컬렉션에 원하는 객체 자료형을 명시하여 실행하기 전에 컴파일 단계에서 특정 컬렉션에 대입 되는 객체가 명시된 객체가 아니면 저장이 불가능하게 할 수있다.

2) 제네릭 타입 (파라미터 타입 Parameterized Type)

제네릭 타입은 <> 사이에 컴파일할 당시 사용될 객체 자료형을 선언한다.
객체를 저장할 때 선언된 제네릭 타입으로만 저장된다.
장점
- <>사이에 선언된 객체 자료형이 아닌 다른 객체형이 저장되는 것을 허용하지 않으므로 컴파일 단계에서부터 프로그램의 안전성을 제시한다.
- Object로 부터 상속받은 객체는 모두 저장이 가능했던 이전의 버전들과는 달리 보다 체계적이라 할 수 있다.
String 객체를 전달하여 저장시키려했지만 실수로 Integer 객체를 저장하게 되더라도 컴파일할 때에는 아무런 문제점을 발견하지 못했다. 
Java Community Process(JCP)를 통해 제시
- 실행 시 자원 검출을 하게 되면 별도의 형 변환(casting)이 필요 없이 <> 사이에 선언했던 객체 자료형으로 검출이되는 데에 큰 무리가 없다

제네릭 타입의 간단한 유형
<한글자로 된 영문 대문자>
<T> : 전달되는 객체가 현 객체 내에서 하나의 자료형(Type)으로 사용 될 때
<E> : 전달되는 객체가 현 객체 내에서 하나의 요소(Element)로 자리를 잡을 때 
<K> : 전달되는 객체가 현 객체 내에서 Key 값으로 사용 될 때
<V> : 전달되는 객체가 현 객체 내에서 Value 값으로 사용 될때

모든 유형들이 전달되는 객체를 코드내에서 하나의 자료형으로 사용되어 무분별했던 지난 과거의 버전들과는 달리 체계적이고 정형화되었다는 것에 큰 의미가 있다.

활용 예)
객체가 생성될 때 상징적 자료형(Generic Type) 이 String 일 경우
T s;	-> String s;
T[] arr;	-> String[] arr;


3) 사용자 정의 제네릭 클래스
[접근제한] class 클래스명<유형 1, 유형2, ... 유형n>

GenericEx1 

4) 제네릭 타입 사용하기
제네릭 클래스의 변수 선언과 생성법
Generic_class명<적용할_제네릭_타입>변수명; // 선언
변수명 = new Generic_class생성자명<적용할_제네릭타입>();// 생성

5) 와일드 카드 타입
기존과 같이 모든 객체들을 저장하고 싶을 경우
<?>  :  모든 객체 자료형에 대한 배치
<? super 객체 자료형>  :  명시도니 객체자료형 또는 객체 자료형의 상위 객체들
<? extends 객체 자료형>  :  명시된 객체 자료형 또는 객체 자료형으로부터 상속 받는 하위 객체 

주의 사항
특정 객체 내에서 사용되는 자료형이 명확하지 않으므로 
1. ?에 배치 시킬 객체는 생성자를 이용해야한다.
2. 와일드카드로 배치된 제네릭 타입은 객체 내부에서 최상위 객체로 인식된다.
<?> : 객체 내부의 모든 제네릭 타입은 Object로 인식
<? super 객체자료형> : 객체 내부의 모든 제네릭 타입은 Object로 인식
<? extends 객체 자료형>  :  객체 내부의 모든 제네릭 타입은 extends 다음에 명시된 객체 자료형

<?>
모든 객체를 의미 
모든 객체를 받아들이는 대신 내부에서는 Object로 인식



























